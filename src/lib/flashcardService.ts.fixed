// filepath: c:\Users\A550191\git\ursa-minor-ascension\src\lib\flashcardService.ts
import type { FlashCard, FlashCardGenerationStatus, Series } from '../types/index';
import type { AzureConfig } from './azure';
import type { FlashCardRequest } from './flashcardGenerator';
import type { FlashCardWorkerMessage, FlashCardWorkerResponse } from './flashcardWorker';
import { saveSeries } from './storage';

// Map to keep track of active workers
const activeWorkers = new Map<string, Worker>();

/**
 * Starts flash card generation for a series
 */
export async function startFlashCardGeneration(
    series: Series,
    config: AzureConfig,
    request: FlashCardRequest,
    onStatusUpdate: (status: FlashCardGenerationStatus) => void,
    onComplete: (flashcards: FlashCard[]) => void,
    onError: (error: string) => void
): Promise<void> {
    // Cleanup any existing worker for this series
    if (activeWorkers.has(series.id)) {
        const existingWorker = activeWorkers.get(series.id);
        existingWorker?.terminate();
        activeWorkers.delete(series.id);
    }

    try {
        // Create a worker using a string path instead of URL constructor
        // This is more compatible with Vite's development mode
        const worker = new Worker(new URL('../workers/flashCardWorker.js', import.meta.url), {
            type: 'module'
        });

        console.log('Worker created successfully');

        // Store worker reference
        activeWorkers.set(series.id, worker);
        
        // Set up message handler
        worker.onmessage = (e: MessageEvent<FlashCardWorkerResponse>) => {
            const response = e.data;
            console.log('Worker response received:', response);

            switch (response.type) {
                case 'status':
                    if (response.status) {
                        console.log('Status update:', response.status);
                        onStatusUpdate(response.status);
                    }
                    break;

                case 'complete':
                    console.log('Generation complete, received cards:', response.flashcards?.length);
                    if (response.flashcards) {
                        onComplete(response.flashcards);
                        // Clean up worker
                        worker.terminate();
                        activeWorkers.delete(series.id);
                    }
                    break;

                case 'error':
                    onError(response.error || 'Unknown error occurred');
                    // Clean up worker
                    worker.terminate();
                    activeWorkers.delete(series.id);
                    break;
            }
        };
        
        worker.onerror = (error) => {
            console.error('Worker error:', error);
            onError(`Worker error: ${error.message || 'Unknown worker error'}`);
            // Clean up worker
            worker.terminate();
            activeWorkers.delete(series.id);
        };
        
        // Start generation
        const message: FlashCardWorkerMessage = {
            type: 'generate',
            series,
            config,
            request
        };

        console.log('Sending message to worker:', message.type);
        worker.postMessage(message);
        console.log('Message sent to worker');

    } catch (error) {
        onError(error instanceof Error ? error.message : 'Failed to start flash card generation');
    }
}

/**
 * Estimates the number of flash cards that can be generated for a series
 */
export function estimateFlashCardCount(
    series: Series,
    config: AzureConfig
): Promise<number> {
    return new Promise((resolve, reject) => {
        // Always calculate a default fallback count
        // This ensures we always have a reasonable value to return no matter what errors occur
        const fallbackCount = Math.min(Math.max(series.pages.length * 3, 5), 50);
        
        // Clean up existing worker if any
        if (activeWorkers.has(series.id)) {
            const existingWorker = activeWorkers.get(series.id);
            existingWorker?.terminate();
            activeWorkers.delete(series.id);
        }
        
        // Set a master timeout to ensure we never get stuck
        const masterTimeoutId = setTimeout(() => {
            console.log('Master timeout triggered, using fallback count');
            resolve(fallbackCount);
            
            // Clean up worker if it exists
            if (activeWorkers.has(series.id)) {
                const worker = activeWorkers.get(series.id);
                worker?.terminate();
                activeWorkers.delete(series.id);
            }
        }, 10000); // 10 second master timeout

        try {
            // Validate config to prevent undefined errors
            if (!config || !config.endpoint || !config.apiKey) {
                console.log('Invalid config, using fallback count');
                clearTimeout(masterTimeoutId);
                resolve(fallbackCount);
                return;
            }
            
            // Create a worker
            const workerUrl = new URL('../workers/flashCardWorker.js', import.meta.url);
            const worker = new Worker(workerUrl, { type: 'module' });

            // Store worker reference
            activeWorkers.set(series.id, worker);

            // Set up message handler
            worker.onmessage = (e: MessageEvent<FlashCardWorkerResponse>) => {
                const response = e.data;

                if (response.type === 'estimate' && response.estimatedCount !== undefined) {
                    clearTimeout(masterTimeoutId); // Clear the timeout
                    resolve(response.estimatedCount);
                    worker.terminate();
                    activeWorkers.delete(series.id);
                } else if (response.type === 'error') {
                    clearTimeout(masterTimeoutId); // Clear the timeout
                    // Calculate a fallback count instead of rejecting
                    console.log('Error in worker, using fallback count:', fallbackCount);
                    resolve(fallbackCount);
                    worker.terminate();
                    activeWorkers.delete(series.id);
                }
            };

            worker.onerror = (error) => {
                clearTimeout(masterTimeoutId); // Clear the timeout
                console.error('Worker error:', error.message);
                // Calculate a fallback count instead of rejecting
                console.log('Worker error, using fallback count:', fallbackCount);
                resolve(fallbackCount);
                worker.terminate();
                activeWorkers.delete(series.id);
            };

            // Start estimation
            const message: FlashCardWorkerMessage = {
                type: 'estimate',
                series,
                config
            };

            worker.postMessage(message);

        } catch (error) {
            clearTimeout(masterTimeoutId);
            console.error('Error creating worker:', error);
            resolve(fallbackCount);
        }
    });
}

/**
 * Updates a series with newly generated flash cards
 */
export async function updateSeriesWithFlashCards(
    seriesId: string,
    flashcards: FlashCard[],
    status: FlashCardGenerationStatus
): Promise<Series> {
    // Import here to avoid circular dependencies
    const { getSeries } = await import('./storage');

    // Get the current series
    const series = await getSeries(seriesId);
    if (!series) {
        throw new Error('Series not found');
    }

    // Update with flash cards
    const updatedSeries: Series = {
        ...series,
        flashcards,
        flashcardStatus: status
    };

    // Save to database
    await saveSeries(updatedSeries);

    return updatedSeries;
}

/**
 * Cancels any ongoing flash card generation for a series
 */
export function cancelFlashCardGeneration(seriesId: string): void {
    if (activeWorkers.has(seriesId)) {
        const worker = activeWorkers.get(seriesId);
        worker?.terminate();
        activeWorkers.delete(seriesId);
        console.log(`Canceled flash card generation for series ${seriesId}`);
    }
}

/**
 * Gets the status of all active flash card generations
 */
export function getActiveGenerations(): string[] {
    return Array.from(activeWorkers.keys());
}
